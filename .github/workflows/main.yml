name: CI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  # test-go:
  #   runs-on: ubuntu-latest

  #   steps:
  #   - name: Check out code
  #     uses: actions/checkout@v3

  #   - name: Build & start database
  #     run: |
  #       docker compose up -d database
  #       until docker compose exec database pg_isready -U test; do
  #         echo "Waiting for databaseâ€¦"
  #         sleep 2
  #       done

  #   - name: Run Go tests in container
  #     run: docker compose run --rm golang go test ./server/handlers -v

  #   - name: Tear down
  #     if: always()
  #     run: docker compose down -v
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      IMAGE_TAG: latest
      DB_REPO: database 
      GO_REPO: go-learn 

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Configure AWS creds
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ap-southeast-2

      - name: Login to ECR
        id: login
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: true

      - name: Build & push Database image
        id: push-db
      #   run: |
      #     IMAGE_URI=${{ steps.login.outputs.registry }}/database:$IMAGE_TAG
      #     docker build -f docker/database.Dockerfile -t $IMAGE_URI .
      #     docker push    $IMAGE_URI
      #     echo "db_image=$IMAGE_URI" >> $GITHUB_OUTPUT

      # - name: Build & push Go image
      #   id: push-go
      #   run: |
      #     IMAGE_URI=${{ steps.login.outputs.registry }}/go-learn:$IMAGE_TAG
      #     docker build -f docker/golang.Dockerfile -t $IMAGE_URI .
      #     docker push    $IMAGE_URI
      #     echo "go_image=$IMAGE_URI" >> $GITHUB_OUTPUT
        run: |
            export ECR_REGISTRY=${{ steps.login.outputs.registry }}
            export DB_REPO
            export GO_REPO
            export IMAGE_TAG
            # Build both images as per docker-compose.yml
            docker compose build
            # Push both to ECR
            docker-compose push

      # first injection: database container
      - name: Render task def (database)
        id: td-db
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: container_definition.json
          container-name:  database
          image:           ${{ steps.push-db.outputs.db_image }}

      # second injection: golang container (uses output from previous)
      - name: Render task def (golang)
        id: td-go
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: ${{ steps.td-db.outputs.task-definition }}
          container-name:  example_exercise_golang_tools
          image:           ${{ steps.push-go.outputs.go_image }}

      - name: Deploy to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.td-go.outputs.task-definition }}
          service:         Container-service-3sxs0kd0
          cluster:         deployment
          wait-for-service-stability: true
